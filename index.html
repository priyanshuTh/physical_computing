<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operating Systems MCQ Study</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --danger-color: #e74c3c;
            --background-color: #f5f7fa;
            --text-color: #2c3e50;
            --card-bg: #ffffff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }

        .progress-container {
            margin-bottom: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            height: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--secondary-color);
            transition: width 0.3s ease;
            width: 0%;
        }

        .stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-weight: bold;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 20px;
        }

        .question {
            font-size: 1.2rem;
            font-weight: 500;
            margin-bottom: 15px;
        }

        .question-number {
            color: var(--primary-color);
            font-weight: bold;
        }

        .options {
            display: grid;
            grid-gap: 10px;
            margin-bottom: 20px;
        }

        .option {
            background-color: #f1f1f1;
            border: 2px solid #ddd;
            border-radius: 5px;
            padding: 10px 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option:hover {
            background-color: #e9e9e9;
            transform: translateY(-2px);
        }

        .option.selected {
            border-color: var(--primary-color);
            background-color: rgba(52, 152, 219, 0.1);
        }

        .option.correct {
            border-color: var(--secondary-color);
            background-color: rgba(46, 204, 113, 0.1);
        }

        .option.incorrect {
            border-color: var(--danger-color);
            background-color: rgba(231, 76, 60, 0.1);
        }

        .buttons {
            display: flex;
            justify-content: space-between;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        button:hover {
            background-color: #2980b9;
            transform: translateY(-2px);
        }

        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .explanation {
            background-color: rgba(52, 152, 219, 0.1);
            border-left: 4px solid var(--primary-color);
            padding: 15px;
            margin-top: 15px;
            border-radius: 5px;
            display: none;
        }

        .topic-selector {
            margin-bottom: 20px;
        }

        .topic-btn {
            background-color: #f1f1f1;
            border: 2px solid #ddd;
            border-radius: 5px;
            padding: 10px 15px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }

        .topic-btn.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .review-container {
            text-align: center;
            display: none;
        }

        .review-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--primary-color);
        }

        .score-display {
            font-size: 2rem;
            margin-bottom: 20px;
        }

        .review-list {
            text-align: left;
            margin-bottom: 20px;
        }

        .review-item {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
        }

        .review-item.correct {
            background-color: rgba(46, 204, 113, 0.1);
        }

        .review-item.incorrect {
            background-color: rgba(231, 76, 60, 0.1);
        }

        .review-question {
            font-weight: bold;
        }

        .review-answer {
            margin-top: 5px;
        }

        /* Study Mode Styles */
        .study-mode {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .mode-switch {
            display: inline-block;
            height: 34px;
            position: relative;
            width: 60px;
        }

        .mode-switch input {
            display: none;
        }

        .slider {
            background-color: #ccc;
            bottom: 0;
            cursor: pointer;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            background-color: white;
            bottom: 4px;
            content: "";
            height: 26px;
            left: 4px;
            position: absolute;
            transition: .4s;
            width: 26px;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--primary-color);
        }

        input:checked+.slider:before {
            transform: translateX(26px);
        }

        .mode-label {
            margin: 0 10px;
            font-weight: bold;
        }

        /* Search Bar */
        .search-container {
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .question {
                font-size: 1.1rem;
            }

            .options {
                grid-gap: 8px;
            }

            .option {
                padding: 8px 12px;
            }

            .buttons button {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Operating Systems MCQ Study</h1>
            <p>Test your knowledge of Operating Systems concepts</p>
        </header>

        <div class="study-mode">
            <span class="mode-label">Quiz Mode</span>
            <label class="mode-switch">
                <input type="checkbox" id="modeToggle">
                <span class="slider"></span>
            </label>
            <span class="mode-label">Study Mode</span>
        </div>

        <div class="topic-selector">
            <button class="topic-btn active" data-topic="all">All Topics</button>
            <button class="topic-btn" data-topic="deadlock">Deadlock</button>
            <button class="topic-btn" data-topic="memory">Memory Management</button>
            <button class="topic-btn" data-topic="virtual">Virtual Memory</button>
        </div>

        <div class="search-container">
            <input type="text" class="search-input" placeholder="Search questions...">
        </div>

        <div class="progress-container">
            <div class="progress-bar"></div>
        </div>

        <div class="stats">
            <div class="question-count">Question: <span id="current">1</span>/<span id="total">0</span></div>
            <div class="score">Score: <span id="score">0</span></div>
        </div>

        <div class="card" id="question-card">
            <div class="question-number">Question <span id="question-num">1</span></div>
            <div class="question" id="question-text"></div>
            <div class="options" id="options-container"></div>
            <div class="explanation" id="explanation"></div>
            <div class="buttons">
                <button id="prev-btn" disabled>Previous</button>
                <button id="check-btn">Check Answer</button>
                <button id="next-btn" disabled>Next</button>
            </div>
        </div>

        <div class="review-container" id="review-container">
            <div class="review-title">Quiz Complete!</div>
            <div class="score-display">Your Score: <span id="final-score">0</span>/<span id="final-total">0</span></div>
            <div class="review-list" id="review-list"></div>
            <button id="restart-btn">Try Again</button>
        </div>
    </div>

    <script>
        // Define the questions array
        const allQuestions = [
            // Deadlock Topic
            {
                topic: "deadlock",
                question: "A set of processes is _________ when each process in the set is blocked awaiting an event that can only be triggered by another blocked process in the set.",
                options: ["spinlocked", "stagnant", "preempted", "deadlocked"],
                correctAnswer: 3,
                explanation: "Deadlock occurs when each process in a set is blocked waiting for a resource that can only be released by another blocked process in the same set, creating a circular dependency."
            },
            {
                topic: "deadlock",
                question: "Examples of __________ include processors, I/O channels, main and secondary memory, devices, and data structures such as files, databases, and semaphores.",
                options: ["regional resources", "joint resources", "reusable resources", "consumable resources"],
                correctAnswer: 2,
                explanation: "Reusable resources are those that can be used by one process at a time and then released for use by other processes. Examples include processors, I/O channels, memory, and various data structures."
            },
            {
                topic: "deadlock",
                question: "With _________ only one process may use a resource at a time and no process may access a resource unit that has been allocated to another process.",
                options: ["hold and wait", "mutual exclusion", "no preemption", "circular wait"],
                correctAnswer: 1,
                explanation: "Mutual exclusion is the condition where only one process can use a resource at a time. This is one of the four necessary conditions for deadlock to occur."
            },
            {
                topic: "deadlock",
                question: "A closed chain of processes exists, such that each process holds at least one resource needed by the next process in the chain is the condition of __________ .",
                options: ["no preemption", "mutual exclusion", "circular wait", "hold and wait"],
                correctAnswer: 2,
                explanation: "Circular wait occurs when there is a circular chain of processes, each waiting for a resource held by the next process in the chain. This is one of the four necessary conditions for deadlock."
            },
            {
                topic: "deadlock",
                question: "Once the processes have progressed into the __________ , those processes will deadlock.",
                options: ["fatal region", "regional resources", "spinlock", "hold and wait"],
                correctAnswer: 0,
                explanation: "The fatal region refers to a state where processes have acquired resources in such a way that deadlock is inevitable. Once processes enter this region, deadlock will occur."
            },
            {
                topic: "deadlock",
                question: "The strategy of deadlock _________ is to design a system in such a way that the possibility of deadlock is excluded.",
                options: ["prevention", "detection", "diversion", "avoidance"],
                correctAnswer: 0,
                explanation: "Deadlock prevention involves designing the system to ensure that at least one of the necessary conditions for deadlock cannot occur, thereby preventing deadlock entirely."
            },
            {
                topic: "deadlock",
                question: "The _________ condition can be prevented by requiring that a process request all of its required resources at one time and blocking the process until all requests can be granted simultaneously.",
                options: ["mutual exclusion", "hold and wait", "circular wait", "no preemption"],
                correctAnswer: 1,
                explanation: "The hold and wait condition can be prevented by requiring processes to request all resources at once before starting execution, rather than acquiring resources incrementally."
            },
            {
                topic: "deadlock",
                question: "The fastest form of interprocess communication provided in UNIX is __________ ",
                options: ["shared memory", "message", "pipe", "semaphore"],
                correctAnswer: 0,
                explanation: "Shared memory is the fastest form of interprocess communication in UNIX because it allows processes to directly access a common memory region without involving the kernel for each data transfer."
            },
            {
                topic: "deadlock",
                question: "The __________ condition can be prevented by defining a linear ordering of resource types.",
                options: ["hold and wait", "no preemption", "mutual exclusion", "circular wait"],
                correctAnswer: 3,
                explanation: "The circular wait condition can be prevented by imposing a linear ordering of resource types, requiring processes to request resources in a specified order, thereby breaking the circular dependency."
            },
            {
                topic: "deadlock",
                question: "Requested resources are granted to processes whenever possible with _________ .",
                options: ["preemption", "deadlock detection", "mutual exclusion", "deadlock avoidance"],
                correctAnswer: 3,
                explanation: "Deadlock avoidance involves granting resource requests only when it's safe to do so, ensuring the system never enters an unsafe state that could lead to deadlock."
            },
            {
                topic: "deadlock",
                question: "One of the most significant contributions of UNIX to the development of operating systems is the _________ .",
                options: ["semaphore", "shared memory", "message", "pipe"],
                correctAnswer: 3,
                explanation: "The pipe is one of UNIX's most significant contributions to operating systems, allowing for simple, yet powerful unidirectional interprocess communication."
            },
            {
                topic: "deadlock",
                question: "A __________ is a software mechanism that informs a process of the occurrence of asynchronous events.",
                options: ["signal", "message", "mailbox", "kernel"],
                correctAnswer: 0,
                explanation: "A signal is a software mechanism in operating systems that informs a process about the occurrence of asynchronous events, allowing processes to handle exceptional conditions."
            },
            {
                topic: "deadlock",
                question: "The most common technique used for protecting a critical section in Linux is the _______ .",
                options: ["signal", "atomic bitmap operation", "atomic integer operation", "spinlock"],
                correctAnswer: 3,
                explanation: "A spinlock is the most common technique used in Linux for protecting critical sections, particularly for short operations, as it provides mutual exclusion through busy-waiting."
            },
            {
                topic: "deadlock",
                question: "The _________ allows multiple threads to have simultaneous read-only access to an object protected by the lock.",
                options: ["barrier", "condition variable", "readers/writer lock", "mutex"],
                correctAnswer: 2,
                explanation: "A readers/writer lock allows multiple threads to read simultaneously while ensuring exclusive access for writers, optimizing performance for read-heavy workloads."
            },
            {
                topic: "deadlock",
                question: "The _________ is useful in sending a signal to a thread indicating that a particular event has occurred.",
                options: ["mutex object", "semaphore object", "event object", "waitable timer object"],
                correctAnswer: 2,
                explanation: "An event object is used to signal threads that a particular event has occurred, allowing threads to wait for specific conditions before proceeding."
            },

            // Memory Management Topic
            {
                topic: "memory",
                question: "Main memory divided into a number of static partitions at system generation time is _______ .",
                options: ["fixed partitioning", "simple segmentation", "dynamic partitioning", "simple paging"],
                correctAnswer: 0,
                explanation: "Fixed partitioning divides main memory into static partitions of fixed sizes at system generation time. This was an early memory management technique with limited flexibility."
            },
            {
                topic: "memory",
                question: "Main memory divided into a number of equal size frames is the __________ technique.",
                options: ["simple paging", "dynamic partitioning", "fixed partitioning", "virtual memory segmentation"],
                correctAnswer: 0,
                explanation: "Simple paging divides physical memory into equal-sized frames, which can then be allocated to processes. This allows for more efficient memory usage than fixed partitioning."
            },
            {
                topic: "memory",
                question: "With __________ a process is loaded by loading all of its segments into dynamic partitions that need not be contiguous.",
                options: ["simple paging", "virtual memory segmentation", "virtual memory paging", "simple segmentations"],
                correctAnswer: 3,
                explanation: "Simple segmentation allows a process to be loaded by placing its segments into dynamic partitions that don't need to be contiguous in physical memory."
            },
            {
                topic: "memory",
                question: "One technique for overcoming external fragmentation is __________ .",
                options: ["loading", "compaction", "relocation", "partitioning"],
                correctAnswer: 1,
                explanation: "Compaction is a technique that moves processes in memory to eliminate external fragmentation by creating a single, large free block of memory instead of many small, scattered free blocks."
            },
            {
                topic: "memory",
                question: "A ___________ is a particular example of logical address in which the address is expressed as a location relative to some known point, usually a value in a processor register.",
                options: ["logical address", "relative address", "absolute address", "physical address"],
                correctAnswer: 1,
                explanation: "A relative address is a logical address expressed as an offset from a known reference point, usually stored in a processor register like the base register."
            },
            {
                topic: "memory",
                question: "The chunks of a process are known as __________ .",
                options: ["pages", "addresses", "frames", "segments"],
                correctAnswer: 0,
                explanation: "Pages are fixed-size chunks of a process's virtual address space in paging memory management systems. These are mapped to physical memory frames."
            },
            {
                topic: "memory",
                question: "Available chunks of memory are known as ___________ .",
                options: ["frames", "segments", "addresses", "pages"],
                correctAnswer: 0,
                explanation: "Frames are fixed-size chunks of physical memory that can be allocated to hold pages from a process's virtual address space in paging memory management."
            },
            {
                topic: "memory",
                question: "The concept of Memory Management satisfies certain system requirements including:",
                options: ["relocation", "protection", "physical organization", "all of the above"],
                correctAnswer: 3,
                explanation: "Memory management satisfies multiple system requirements including relocation (allowing processes to be moved in memory), protection (preventing unauthorized access), and physical organization (efficiently using available memory)."
            },
            {
                topic: "memory",
                question: "In the Dynamic Partitioning technique of memory management, the placement algorithm that chooses the block that is closest in size to the request is called __________ .",
                options: ["first-fit", "best-fit", "last-fit", "next-fit"],
                correctAnswer: 1,
                explanation: "Best-fit is a placement algorithm that allocates the smallest free block large enough to accommodate the request, minimizing wasted space but potentially leading to small, unusable fragments."
            },
            {
                topic: "memory",
                question: "In the Dynamic Partitioning technique of memory management, the placement algorithm that scans memory from the location of the last placement and chooses the next available block that is large enough to satisfy the request is called __________ .",
                options: ["last-fit", "best-fit", "next-fit", "first-fit"],
                correctAnswer: 2,
                explanation: "Next-fit is a placement algorithm that starts searching from the location of the last placement, improving performance over first-fit by distributing allocations more evenly across memory."
            },
            {
                topic: "memory",
                question: "A problem with the largely obsolete Fixed Partitioning memory management technique is that of:",
                options: ["allowing only a fixed number of processes", "inefficient use of memory", "internal fragmentation", "all of the above"],
                correctAnswer: 3,
                explanation: "Fixed partitioning suffers from multiple problems: it limits the number of active processes, uses memory inefficiently, and leads to internal fragmentation when processes are smaller than their assigned partitions."
            },
            {
                topic: "memory",
                question: "The page table for each process maintains _________ .",
                options: ["the physical memory location of the process", "the frame location for each page of the process", "the page location for each frame of the process", "the logical memory location of the process"],
                correctAnswer: 1,
                explanation: "The page table maintains the mapping between a process's virtual pages and their corresponding physical memory frames, allowing the system to translate virtual addresses to physical addresses."
            },
            {
                topic: "memory",
                question: "In a system employing a segmentation scheme for memory management wasted space is due to _________ .",
                options: ["external fragmentation", "frames of different sizes", "internal fragmentation", "segments of different sizes"],
                correctAnswer: 0,
                explanation: "In segmentation, wasted space is primarily due to external fragmentation, where free memory is divided into small, non-contiguous blocks that cannot be efficiently allocated to processes."
            },
            {
                topic: "memory",
                question: "In a system employing a paging scheme for memory management wasted space is due to _________ .",
                options: ["internal fragmentation", "pages of different specified sizes", "external fragmentation", "frames of different specified sizes"],
                correctAnswer: 0,
                explanation: "In paging, wasted space is primarily due to internal fragmentation, where allocated frames are not fully utilized because the process's memory requirements don't align perfectly with page boundaries."
            },
            {
                topic: "memory",
                question: "In a system employing a segmentation scheme for memory management a process is divided into _________ .",
                options: ["one segment per thread", "a number of threads", "a number of segments which need not be of equal size", "a number of segments which must be of equal size"],
                correctAnswer: 2,
                explanation: "In segmentation, a process is divided into logical segments (like code, data, stack) that can be of different sizes, reflecting the logical structure of the program rather than fixed-size units."
            },

            // Virtual Memory Topic
            {
                topic: "virtual",
                question: "The address of a storage location in main memory is the __________ .",
                options: ["address space", "virtual address space", "real address", "virtual address"],
                correctAnswer: 2,
                explanation: "The real address (also called physical address) refers to the actual location in main memory where data is stored. This is distinct from virtual addresses used by processes."
            },
            {
                topic: "virtual",
                question: "_________ is the virtual storage assigned to a process.",
                options: ["Virtual address space", "Virtual address", "Real address", "Address space"],
                correctAnswer: 0,
                explanation: "Virtual address space is the range of virtual addresses assigned to a process, independent of the physical memory available, allowing processes to operate as if they have more memory than physically exists."
            },
            {
                topic: "virtual",
                question: "__________ is the range of memory addresses available to a process.",
                options: ["Address space", "Real address", "Virtual address", "Virtual address space"],
                correctAnswer: 0,
                explanation: "Address space refers to the range of memory addresses available to a process, which can be either virtual (logical) or physical depending on the context."
            },
            {
                topic: "virtual",
                question: "The __________ structure indexes page table entries by frame number rather than by virtual page number.",
                options: ["hash table", "segment table", "page table", "inverted page table"],
                correctAnswer: 3,
                explanation: "An inverted page table indexes entries by frame number rather than by virtual page number, reducing memory overhead by having one entry per frame instead of one per virtual page."
            },
            {
                topic: "virtual",
                question: "The _________ states the process that owns the page.",
                options: ["process identifier", "control bits", "page number", "chain pointer"],
                correctAnswer: 0,
                explanation: "The process identifier (PID) in a page table entry indicates which process owns the particular page, essential for managing memory in a multi-process environment."
            },
            {
                topic: "virtual",
                question: "A _________ is issued if a desired page is not in main memory.",
                options: ["paging error", "page replacement policy", "page fault", "page placement policy"],
                correctAnswer: 2,
                explanation: "A page fault occurs when a process tries to access a page that is not currently in physical memory, triggering the operating system to load the page from secondary storage."
            },
            {
                topic: "virtual",
                question: "_________ allows the programmer to view memory as consisting of multiple address spaces.",
                options: ["Paging", "Locality", "Segmentation", "Thrashing"],
                correctAnswer: 2,
                explanation: "Segmentation allows programmers to view memory as consisting of multiple, logically separate address spaces (like code, data, stack), reflecting the program's structure."
            },
            {
                topic: "virtual",
                question: "__________ is transparent to the programmer and eliminates external fragmentation providing efficient use of main memory.",
                options: ["Hashing", "Paging", "Segmentation", "Thrashing"],
                correctAnswer: 1,
                explanation: "Paging is transparent to the programmer and eliminates external fragmentation by dividing memory into fixed-size frames, allowing more efficient use of physical memory."
            },
            {
                topic: "virtual",
                question: "The _________ determines when a page should be brought into main memory.",
                options: ["page fault", "fetch policy", "working set", "resident set management"],
                correctAnswer: 1,
                explanation: "The fetch policy determines when pages should be brought into main memory - either on demand (when a page fault occurs) or through anticipatory loading (prepaging)."
            },
            {
                topic: "virtual",
                question: "With _________ pages other than the one demanded by a page fault are brought in.",
                options: ["slab allocation", "thrashing", "hashing", "prepaging"],
                correctAnswer: 3,
                explanation: "Prepaging brings in additional pages beyond the one that caused a page fault, anticipating future needs based on locality of reference, potentially reducing the total number of page faults."
            },
            {
                topic: "virtual",
                question: "The _________ policy results in the fewest number of page faults.",
                options: ["Optimal", "FIFO", "Clock", "LRU"],
                correctAnswer: 0,
                explanation: "The Optimal page replacement policy (which replaces the page that won't be used for the longest time in the future) results in the fewest page faults, but is theoretical as it requires knowledge of future references."
            },
            {
                topic: "virtual",
                question: "A _________ chooses only among the resident pages of the process that generated the page fault in selecting a page to replace.",
                options: ["global replacement policy", "page replacement policy", "local replacement policy", "page placement policy"],
                correctAnswer: 2,
                explanation: "A local replacement policy restricts page replacement to the process that caused the page fault, preventing one process from stealing frames from another process."
            },
            {
                topic: "virtual",
                question: "The _________ algorithm requires a use bit to be associated with each page in memory.",
                options: ["page placement", "working set", "VSWS", "page fault frequency"],
                correctAnswer: 1,
                explanation: "The working set algorithm uses a use bit to track which pages have been referenced recently, helping to identify the working set of pages a process actively needs."
            },
            {
                topic: "virtual",
                question: "_________ is where modified process pages can be written out at the time of replacement, or a precleaning policy can be used, which clusters the output activity by writing out a number of pages at once.",
                options: ["Load control", "Cleaning policy", "Placement policy", "Replacement policy"],
                correctAnswer: 1,
                explanation: "Cleaning policy determines when modified pages are written back to secondary storage - either at replacement time or through precleaning, which writes out multiple pages at once to improve efficiency."
            },
            {
                topic: "virtual",
                question: "_________ is the concept associated with determining the number of processes that will be resident in main memory.",
                options: ["Virtual memory manager", "Page fault frequency", "LRU policy", "Load Control"],
                correctAnswer: 3,
                explanation: "Load control determines how many processes should be resident in main memory simultaneously, balancing the needs of individual processes against overall system performance."
            }
        ];

        // Initialize variables
        let currentQuestions = [...allQuestions];
        let currentIndex = 0;
        let score = 0;
        let answered = [];
        let selectedOption = null;
        let isChecked = false;
        let isStudyMode = false;

        // DOM Elements
        const questionText = document.getElementById('question-text');
        const optionsContainer = document.getElementById('options-container');
        const currentQuestionEl = document.getElementById('current');
        const totalQuestionsEl = document.getElementById('total');
        const scoreEl = document.getElementById('score');
        const progressBar = document.querySelector('.progress-bar');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const checkBtn = document.getElementById('check-btn');
        const explanationEl = document.getElementById('explanation');
        const questionCard = document.getElementById('question-card');
        const reviewContainer = document.getElementById('review-container');
        const finalScoreEl = document.getElementById('final-score');
        const finalTotalEl = document.getElementById('final-total');
        const reviewListEl = document.getElementById('review-list');
        const restartBtn = document.getElementById('restart-btn');
        const questionNumEl = document.getElementById('question-num');
        const modeToggle = document.getElementById('modeToggle');
        const topicBtns = document.querySelectorAll('.topic-btn');
        const searchInput = document.querySelector('.search-input');

        // Initialize the quiz
        function initQuiz() {
            currentQuestions = [...allQuestions];
            shuffleQuestions();
            currentIndex = 0;
            score = 0;
            answered = Array(currentQuestions.length).fill(false);
            updateStats();
            showQuestion();
        }

        // Shuffle the questions array
        function shuffleQuestions() {
            for (let i = currentQuestions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentQuestions[i], currentQuestions[j]] = [currentQuestions[j], currentQuestions[i]];
            }
        }

        // Display the current question
        function showQuestion() {
            const question = currentQuestions[currentIndex];
            questionText.textContent = question.question;
            questionNumEl.textContent = currentIndex + 1;

            // Clear options
            optionsContainer.innerHTML = '';

            // Create option elements
            question.options.forEach((option, index) => {
                const optionElement = document.createElement('div');
                optionElement.classList.add('option');
                optionElement.textContent = option;
                optionElement.dataset.index = index;

                // Add classes based on previous answers
                if (answered[currentIndex]) {
                    if (index === selectedOption) {
                        optionElement.classList.add('selected');
                        if (index === question.correctAnswer) {
                            optionElement.classList.add('correct');
                        } else {
                            optionElement.classList.add('incorrect');
                        }
                    } else if (index === question.correctAnswer) {
                        optionElement.classList.add('correct');
                    }
                }

                optionElement.addEventListener('click', selectOption);
                optionsContainer.appendChild(optionElement);
            });

            // Show explanation in study mode or if already answered
            if (isStudyMode || answered[currentIndex]) {
                explanationEl.textContent = question.explanation;
                explanationEl.style.display = 'block';
            } else {
                explanationEl.style.display = 'none';
            }

            // Update button states
            updateButtonStates();

            // Update progress bar
            updateProgressBar();
        }

        // Handle option selection
        function selectOption(e) {
            if (answered[currentIndex] && !isStudyMode) return;

            // Clear previous selection
            const options = document.querySelectorAll('.option');
            options.forEach(opt => opt.classList.remove('selected'));

            // Select the clicked option
            const selectedElement = e.target;
            selectedElement.classList.add('selected');
            selectedOption = parseInt(selectedElement.dataset.index);

            // In study mode, show answer immediately
            if (isStudyMode) {
                checkAnswer();
            }
        }

        // Check the selected answer
        function checkAnswer() {
            if (selectedOption === null) {
                alert('Please select an option!');
                return;
            }

            const options = document.querySelectorAll('.option');
            const correctAnswer = currentQuestions[currentIndex].correctAnswer;

            options.forEach((option, index) => {
                if (index === correctAnswer) {
                    option.classList.add('correct');
                }

                if (index === selectedOption && selectedOption !== correctAnswer) {
                    option.classList.add('incorrect');
                }
            });

            // Update score if not already answered
            if (!answered[currentIndex]) {
                if (selectedOption === correctAnswer) {
                    score++;
                }
                answered[currentIndex] = true;
                updateStats();
            }

            // Show explanation
            explanationEl.textContent = currentQuestions[currentIndex].explanation;
            explanationEl.style.display = 'block';

            // Enable next button
            nextBtn.disabled = false;

            // Change check button to next if not on the last question
            if (currentIndex < currentQuestions.length - 1) {
                checkBtn.textContent = 'Next';
                checkBtn.removeEventListener('click', checkAnswer);
                checkBtn.addEventListener('click', goToNext);
            } else {
                checkBtn.textContent = 'Show Results';
                checkBtn.removeEventListener('click', checkAnswer);
                checkBtn.addEventListener('click', showResults);
            }

            isChecked = true;
        }

        // Go to the next question
        function goToNext() {
            if (currentIndex < currentQuestions.length - 1) {
                currentIndex++;
                selectedOption = null;
                isChecked = false;
                showQuestion();

                // Reset check button
                checkBtn.textContent = 'Check Answer';
                checkBtn.removeEventListener('click', goToNext);
                checkBtn.addEventListener('click', checkAnswer);
            }
        }

        // Go to the previous question
        function goToPrevious() {
            if (currentIndex > 0) {
                currentIndex--;
                selectedOption = null;
                isChecked = false;
                showQuestion();

                // Reset check button if previously checked
                if (answered[currentIndex]) {
                    checkBtn.textContent = 'Next';
                    checkBtn.removeEventListener('click', checkAnswer);
                    checkBtn.addEventListener('click', goToNext);
                } else {
                    checkBtn.textContent = 'Check Answer';
                    checkBtn.removeEventListener('click', goToNext);
                    checkBtn.addEventListener('click', checkAnswer);
                }
            }
        }

        // Update button states based on current position
        function updateButtonStates() {
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = !answered[currentIndex] && !isStudyMode;

            if (isStudyMode) {
                checkBtn.style.display = 'none';
            } else {
                checkBtn.style.display = 'block';

                if (answered[currentIndex]) {
                    checkBtn.textContent = currentIndex < currentQuestions.length - 1 ? 'Next' : 'Show Results';
                    checkBtn.removeEventListener('click', checkAnswer);
                    checkBtn.addEventListener('click', currentIndex < currentQuestions.length - 1 ? goToNext : showResults);
                } else {
                    checkBtn.textContent = 'Check Answer';
                    checkBtn.removeEventListener('click', goToNext);
                    checkBtn.removeEventListener('click', showResults);
                    checkBtn.addEventListener('click', checkAnswer);
                }
            }
        }

        // Update the stats display
        function updateStats() {
            currentQuestionEl.textContent = currentIndex + 1;
            totalQuestionsEl.textContent = currentQuestions.length;
            scoreEl.textContent = score;
        }

        // Update the progress bar
        function updateProgressBar() {
            const progress = ((currentIndex + 1) / currentQuestions.length) * 100;
            progressBar.style.width = `${progress}%`;
        }

        // Show the final results
        function showResults() {
            questionCard.style.display = 'none';
            reviewContainer.style.display = 'block';

            finalScoreEl.textContent = score;
            finalTotalEl.textContent = currentQuestions.length;

            // Generate review list
            reviewListEl.innerHTML = '';
            currentQuestions.forEach((question, index) => {
                const isCorrect = answered[index] && (getSelectedOptionForQuestion(index) === question.correctAnswer);

                const reviewItem = document.createElement('div');
                reviewItem.classList.add('review-item');
                reviewItem.classList.add(isCorrect ? 'correct' : 'incorrect');

                const reviewQuestion = document.createElement('div');
                reviewQuestion.classList.add('review-question');
                reviewQuestion.textContent = `Q${index + 1}: ${question.question}`;

                const reviewAnswer = document.createElement('div');
                reviewAnswer.classList.add('review-answer');
                if (answered[index]) {
                    const selectedIndex = getSelectedOptionForQuestion(index);
                    reviewAnswer.textContent = `Your answer: ${question.options[selectedIndex]} | Correct answer: ${question.options[question.correctAnswer]}`;
                } else {
                    reviewAnswer.textContent = `Not answered | Correct answer: ${question.options[question.correctAnswer]}`;
                }

                reviewItem.appendChild(reviewQuestion);
                reviewItem.appendChild(reviewAnswer);
                reviewListEl.appendChild(reviewItem);
            });
        }

        // Get the selected option for a specific question
        function getSelectedOptionForQuestion(index) {
            // This is a simplified implementation since we don't track all selections
            // In a real app, you'd store all selections in an array
            return index === currentIndex ? selectedOption : -1;
        }

        // Restart the quiz
        function restartQuiz() {
            reviewContainer.style.display = 'none';
            questionCard.style.display = 'block';

            initQuiz();
        }

        // Toggle between quiz and study mode
        function toggleMode() {
            isStudyMode = modeToggle.checked;

            if (isStudyMode) {
                // In study mode, always show explanations and enable navigation
                explanationEl.style.display = 'block';
                nextBtn.disabled = false;
                checkBtn.style.display = 'none';
            } else {
                // In quiz mode, hide explanations until answered
                if (!answered[currentIndex]) {
                    explanationEl.style.display = 'none';
                }
                checkBtn.style.display = 'block';
                updateButtonStates();
            }
        }

        // Filter questions by topic
        function filterByTopic(topic) {
            // Update active topic button
            topicBtns.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.topic === topic) {
                    btn.classList.add('active');
                }
            });

            // Filter questions
            if (topic === 'all') {
                currentQuestions = [...allQuestions];
            } else {
                currentQuestions = allQuestions.filter(q => q.topic === topic);
            }

            // Reset quiz state
            currentIndex = 0;
            score = 0;
            answered = Array(currentQuestions.length).fill(false);

            // Update display
            updateStats();
            showQuestion();
        }

        // Search questions
        function searchQuestions() {
            const searchTerm = searchInput.value.toLowerCase();

            if (searchTerm.trim() === '') {
                // If search is empty, get questions from the currently selected topic
                const activeTopic = document.querySelector('.topic-btn.active').dataset.topic;
                filterByTopic(activeTopic);
                return;
            }

            // Filter based on active topic first
            const activeTopic = document.querySelector('.topic-btn.active').dataset.topic;
            let baseQuestions = activeTopic === 'all' ? allQuestions : allQuestions.filter(q => q.topic === activeTopic);

            // Then filter by search term
            currentQuestions = baseQuestions.filter(question => {
                return (
                    question.question.toLowerCase().includes(searchTerm) ||
                    question.options.some(option => option.toLowerCase().includes(searchTerm)) ||
                    question.explanation.toLowerCase().includes(searchTerm)
                );
            });

            // Reset quiz state
            currentIndex = 0;
            score = 0;
            answered = Array(currentQuestions.length).fill(false);

            // Update display
            updateStats();
            showQuestion();
        }

        // Event listeners
        prevBtn.addEventListener('click', goToPrevious);
        nextBtn.addEventListener('click', goToNext);
        checkBtn.addEventListener('click', checkAnswer);
        restartBtn.addEventListener('click', restartQuiz);
        modeToggle.addEventListener('change', toggleMode);

        // Topic filter listeners
        topicBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                filterByTopic(btn.dataset.topic);
            });
        });

        // Search listener
        searchInput.addEventListener('input', searchQuestions);

        // Initialize the quiz
        initQuiz();
    </script>
</body>

</html>